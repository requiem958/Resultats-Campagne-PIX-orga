import io
from datetime import datetime

sortie_pdf = True

# Les bibliothèques au dessus sont standards dans python
# On vérifie la présence de requests et pandas qui sont obligatoires
# On vérifie la présence de xhtml2pdf qui est facultative (pour faire une sortie pdf et pas html)
# La sortie pdf ralentit considérablement l'éxécution

testbibliotheque = True

try : 
    import requests
except:
    print("!!! Bibliothèque requests absente. Installez la bibliothèque requests. !!!")
    testbibliotheque = False

try : 
    import pandas as pd
except:
    print("!!! Bibliothèque pandas absente. Installez la bibliothèque pandas. !!!")
    testbibliotheque = False
    
if not(testbibliotheque):
    print("!!! Le programme nécessite l'installation de bibliothèques python pour fonctionner !!!")
    quit()

if sortie_pdf :
    try :
        from xhtml2pdf import pisa
    except:
        print("!!! Bibliothèque xhtml2pdf absente. Pas de sortie pdf possible. Sortie en html !!!")
        sortie_pdf = False

def donnees_perso():
    username=input("Adresse mail associé à pix orga ? ")
    password=input("Mot de passe pix orga ? ")
    
    return username,password


def identification(username,password):
    data={'username':username,'password':password}
    try :
        r = requests.post("https://orga.pix.fr/api/token", data)
        token=str(r.json()['access_token'])
        user_id=str(r.json()['user_id'])
        return token,user_id
    except:
        print("!!! Erreur de connexion à Pix Orga. Vérifier identifiant et mot de passe  !!!")
        quit()


def choix_organisation(token,user_id):
    headers={'Authorization': 'Bearer '+ token}
    r = requests.get("https://orga.pix.fr/api/prescription/prescribers/"+user_id, headers=headers)
    organisations=[]
    print("Nom des organisations auxquelles vous êtes rattaché dans pix orga")
    for c in r.json()['included']:
        if c['type']=='organizations':
            organisations.append(c)
            print("Identifiant | Nom")
            print( c['id'],"       |",c['attributes']['name'])
        
    if len(organisations)>1:
        print("Choisissez l'organisation à traiter")
        organisation_id=input("Identifiant :")
    elif len(organisations)==1:
        organisation_id=organisations[0]['id']

    organisation_id=str(organisation_id)
    return organisation_id


def liste_campagnes(token,organisation_id,nb_campagnes_max=100):
    headers={'Authorization': 'Bearer '+ token}
    nb_campagnes_max = str(nb_campagnes_max)
    print("Récupération des résultats des dernières campagnes non archivées (max = "+str(nb_campagnes_max)+" campagnes)")
    r = requests.get("https://orga.pix.fr/api/organizations/"+organisation_id+"/campaigns?page[number]=1&page[size]="+nb_campagnes_max, headers=headers)
    campagnes=r.json()['data']
    return campagnes
    
def lecture_campagne(token,campagne) :
    headers={'Authorization': 'Bearer '+ token}
    donnees=[]
    
    r = requests.get("https://orga.pix.fr/api/campaigns/"+str(campagne['id']), headers=headers)
    token_pour_csv = r.json()['data']['attributes']['token-for-campaign-results']
    if campagne['attributes']['type']=='ASSESSMENT':
        type_campagne="assessment"
    elif campagne['attributes']['type']=='PROFILES_COLLECTION':
        type_campagne="profiles-collection"
    
    url_csv="https://orga.pix.fr/api/campaigns/"+str(campagne['id'])+"/csv-"+type_campagne+"-results?accessToken="+token_pour_csv+"&lang=fr"
    
    try :
        r = requests.get(url_csv)
        # permet de simuler le flux d'un fichier
        fichier_lecture =io.BytesIO(r.content)
        
    except:
        print("!!! Fichier csv en erreur de lecture. Campagne : "+campagne['attributes']['name']+" !!!")
        return "", ""
    
    try : 
        nom_fichier_csv=r.headers.get("Content-Disposition").split("filename=")[1]
        print(nom_fichier_csv)
        resultats = pd.read_csv(fichier_lecture,sep=';',quotechar='"',decimal=',',dtype={'Classe':'str'})        
        return campagne['attributes']['name'], resultats
    except:
        print("!!! Fichier csv en erreur de traitement. Campagne : "+campagne['attributes']['name']+" !!!")
        return "", ""
    
    
def liste_eleves(token,organisation_id,nb_eleves_max=3000):
    print("Récupération de la liste des élèves (max = "+str(nb_eleves_max)+" élèves)")
    listeeleves = []

    headers={'Authorization': 'Bearer '+ token}
    r = requests.get("https://orga.pix.fr/api/organizations/"+organisation_id+"/students?page[size]="+str(nb_eleves_max), headers=headers)
    
    for e in r.json()['data']:
        listeeleves.append((e['attributes']['last-name'],e['attributes']['first-name'],e['attributes']['division']))
        
    eleves=pd.DataFrame(listeeleves, columns=('Nom du Participant','Prénom du Participant','Classe',))
    eleves.sort_values(by=['Classe', 'Nom du Participant','Prénom du Participant'],inplace = True)

    return eleves

def traitement_campagne(nom_campagne,resultats,resultats_globaux):

    
    
    # Mise en forme de colonne en pourcentage
    if '% de progression' in resultats.columns :
        # Recherche non finalisé
        masquenonfinalise=(resultats['% de progression']==1) & (resultats['Partage (O/N)']=="Non")
        resultats['% de progression'] = resultats['% de progression'].apply(lambda x: str(round(float(x)*100,1))+'%' if isinstance(x,(int,float)) else x)
    
    if "% maitrise de l'ensemble des acquis du profil" in resultats.columns :
        resultats.rename(columns = {"% maitrise de l'ensemble des acquis du profil":'% de réussite'}, inplace = True)
        resultats['% de réussite'] = resultats['% de réussite'].where(~masquenonfinalise,"Non finalisé")
        masque=pd.notna(resultats['% de réussite'])
        resultats['% de réussite'] = resultats['% de réussite'].where(masque,"En cours")
        resultats['% de réussite'] = resultats['% de réussite'].apply(lambda x: str(round(float(x)*100,1))+'%' if isinstance(x,(int,float)) else x)
        
        # Recensement résultats globaux
        resultats['% de réussite - ' + nom_campagne]=resultats['% de réussite']
        
        if not(resultats.empty):
            resultats_globaux = pd.merge(right=resultats_globaux,left=resultats.loc[:,['Classe', 'Nom du Participant','Prénom du Participant','% de réussite - '+nom_campagne]],how='outer',on=['Classe', 'Nom du Participant','Prénom du Participant'])
        
    
    # Pour traiter les campagnes de rentrée de type "Pour commencer ..."
    if 'Palier obtenu (/3)' in resultats.columns :
        resultats = resultats.loc[:,[ 'Nom du Participant','Prénom du Participant','Classe','% de progression','Palier obtenu (/3)','% de réussite']]
        resultats['Palier obtenu (/3)'] = resultats['Palier obtenu (/3)'].where(~(masquenonfinalise) ,'Non finalisé')
        masque=pd.notna(resultats['Palier obtenu (/3)'])
        resultats['Palier obtenu (/3)'] = resultats['Palier obtenu (/3)'].where(masque,'En cours')

    # Pour traiter la campagne de vérification des certifiables
    elif 'Certifiable (O/N)' in resultats.columns :
        resultats = resultats.loc[:,[ 'Nom du Participant','Prénom du Participant','Classe','Nombre de pix total','Certifiable (O/N)','Nombre de compétences certifiables']]
        
        # Recensement résultats globaux
        if not(resultats.empty):
            masque=pd.notna(resultats['Certifiable (O/N)'])
            resultats['Certifiable (O/N)'] = resultats['Certifiable (O/N)'].where(masque,'Non finalisé')
            resultats_globaux = pd.merge(right=resultats_globaux,left=resultats.loc[:,['Classe', 'Nom du Participant','Prénom du Participant','Certifiable (O/N)']],how='outer',on=['Classe', 'Nom du Participant','Prénom du Participant'])
            print("!!! Ce message indique le traitement d'une récolte de profil.       !!!")
            print("!!! Il est souhaitable qu'il n'y en ait qu'une pour tous les élèves !!!") 

        
    # Pour traiter les autres campagnes
    else :
        resultats = resultats.loc[:,[ 'Nom du Participant','Prénom du Participant','Classe','% de progression','Partage (O/N)','% de réussite']]
        resultats.rename(columns = {'Partage (O/N)':'Finalisé (O/N)'}, inplace = True)        

    resultats_globaux['Connecté']='Oui'

    return resultats, resultats_globaux

def sortie_par_classe(nom_campagne,resultats,eleves,sortie_pdf=False):
    resultats.sort_values(by=['Classe', 'Nom du Participant','Prénom du Participant'],inplace = True)
    liste_des_classes = resultats['Classe'].unique()
    

    # Fusion avec la liste de tous les élèves
    resultats=resultats.merge(eleves,how='outer',on=['Classe', 'Nom du Participant','Prénom du Participant'])

    formatageA4portrait = '<style type="text/css">'\
    ' @page {@frame content_frame {left: 10pt;width: 556pt;top: 10pt;height: 802pt;}'\
    ' size: A4 portrait}'\
    ' h1 {font-size: 16px}'\
    ' h2 {font-size: 14px}'\
    ' table{ font-size: 12px ;font-family: sans-serif; border-collapse: collapse;  }'\
    ' td, th{border: 1px solid #ddd; padding: 3px;}'\
    ' th{text-align: left;  background-color: #1e7375;  color: white;}'\
    ' tr{padding:2px}'\
    ' tr:nth-child(even){background-color: #f2f2f2;}'\
    ' a{text-decoration:none; color:black; }'\
    ' </style>'
    
    titre = nom_campagne +" - "+ datetime.now().strftime('%Y-%m-%d')

    texte_HTML=formatageA4portrait +'<h1>'+ titre +'</h1><p>Cliquer sur la classe pour voir la synthèse des résultats</p>'
    
    # Liste des classes à cliquer
    if len(liste_des_classes)>0:
        texte_HTML += '<table><tr>'
        n=1
        for classe in liste_des_classes :
            texte_HTML += '<td><a href="#'+classe+'">'+ classe +'</a></td>'
            if n%6==0 and n != len(liste_des_classes) :
                    texte_HTML +='</tr><tr> '
                    
            n+=1    
        
        texte_HTML +='</tr></table><div style="page-break-before:always">&nbsp;</div>'
    
    # Liste des résultats par classe
    for classe in liste_des_classes :
        resultats_classe = resultats[resultats['Classe']==classe].dropna(how='all',axis='columns')
        texte_HTML += '<a name="'+classe+'"><h2>'+ classe +' - '+ titre+'</h2></a>'+ resultats_classe.to_html(index=False,na_rep="-")+ '<div style="page-break-before:always">&nbsp;</div>'

    
    # Traitement des caractères interdits dans un nom de fichier
    dico=titre.maketrans('\/:*?"<>|','---------')
    nom_du_fichier = titre.translate(dico)

    if sortie_pdf :
        fichier_PDF = open(nom_du_fichier+ '.pdf', "w+b")
        pisa.CreatePDF(texte_HTML,fichier_PDF)
        fichier_PDF.close() 
    else :
        fichier_HTML = open(nom_du_fichier+'.html', "w")
        fichier_HTML.write(texte_HTML)
        fichier_HTML.close()

    
    

username,password = donnees_perso() 
token,user_id=identification(username,password)
del username
del password
organisation_id=choix_organisation(token,user_id)
eleves=liste_eleves(token,organisation_id)
campagnes=liste_campagnes(token,organisation_id)
resultats_globaux=pd.DataFrame(columns=['Nom du Participant','Prénom du Participant','Classe','Connecté'])

for campagne in campagnes :
    nom_campagne,resultats=lecture_campagne(token,campagne)
    if nom_campagne!="":
        resultats,resultats_globaux=traitement_campagne(nom_campagne,resultats,resultats_globaux)
        sortie_par_classe(nom_campagne,resultats,eleves,sortie_pdf)

# Fusion avec la liste de tous les élèves pour permettre la synthèse sur toutes les classes même celles sans élèves ayant répondu
resultats_globaux=resultats_globaux.merge(eleves,how='outer',on=['Classe', 'Nom du Participant','Prénom du Participant'])
sortie_par_classe('Synthèse résultats Pix par classe',resultats_globaux,eleves,sortie_pdf)
